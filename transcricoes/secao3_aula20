Eu sei que para algumas pessoas esse foi basicamente seu primeiro código assembly certo.
Quando você escreveu o código, você disse: você montou isso e abriu o depurador stella e viu
tipo, todas as posições de memória diminuem de ff até 00 esvaziando valores dos bancos.
Mas e se eu lhe dissesse que você não apenas escreveu seu primeiro código assembly, mas também escreveu o primeiro bug em assembly
então eu sei que algumas pessoas provavelmente já sinalizaram isso.
E antes que voce fique louco de raiva e me escreva um e-mail dizendo o quão ruim eu sou, eu sei, certo.
Eu sei que temos um bug aqui.
Então, para todos os outros que não perceberam isso, quero que reservemos um momento.
Quero que analisemos o que está acontecendo e por que nosso programa pode ter um bug.

Lembre-se do objetivo do nosso programa.
Queríamos sair da posição de memŕia com FF e queremos esvaziá-la zero, mas qual é o problema?

Você vê o próximo instantâneo e estávamos olhando.
Esta não é uma visão completa de tráfego zero zero.

Se você olhar atentamente para o canto superior esquerdo, verá que inicia a visualização que temos de 8 0 até

que.

Então é quase como se tivéssemos toda essa outra metade da memória de 0 0 a 8 0 que não estamos visualizando

aqui.

E com isso em mente quero que você volte ao seu código.

Reserve alguns minutos, segundos e minutos para ver se você consegue identificar.

Eu entendo o circuito.

Entenda o que estamos fazendo e talvez qual é o problema que não estamos fazendo corretamente

com nosso código.

Vou lhe dar alguns segundos para ver se você consegue identificar o erro e provavelmente voltarei

três 4 segundos.

Então você descobriu o que está acontecendo em nosso código e por que ele pode estar com defeito, apenas para ilustrar

o que estávamos fazendo, quero dar um exemplo rápido aqui.

Deixe-me vir aqui rapidamente e quero definir algumas posições de memória também, de forma aleatória.

Sim, sim, e de certa forma coloquei várias posições aqui, nove e oito.

Você tem um quatro, estou apenas configurando alguns bits aleatórios.

Então, se eu entrar aqui e disser uma vez que você disse programa e eu fui à força, o problema foi resolvido

comece com a primeira linha.

Então, se eu começar linha por linha, devemos ver todas essas oito posições começando de uma posição rápida.

sendo zerado indo até zero.

Então, se eu subir, começo meu loop assim que repetir, alcance a linha do meu loop aqui, você verá

que eu tenho sim eu respeito zero aqui

e então este provavelmente será 0 0 abaixo de 0 0.

Então, todas as posições de memória dele estou baixando e esvaziando-as com zero certo.

Mas vamos apenas entrar.

Eu fui lá porque eles estão se tornando zero.

Fui trapacear um pouco.

Quero que você vá ver nosso ex registrador lá em cima é aquele que faz contagem regressiva de F após 0 com você.

Eu quero trapacear e quero fingir.

Vamos fingir por um momento que digitalizamos todas as posições dos membros até, digamos, 0 8.

Certo.

Digamos apenas que temos apenas de 8 2 0 para baixo de 2 0 até ficar meio vazio.

Então vamos fingir que tudo foi escaneado já que estamos lá.

Vejo você às 8.

Como eu venho aqui e se eu pisar vou decrementar X vai ser 7.

Então ramifiquei e ainda não é zero.

Vou ramificar, então vou armazenar zero na posição sete, então vou aqui e vejo zero

então sete economiza um decremento de sete valor x seis loop save zero na posição seis decremento loop save

zero na posição cinco incremento Luke salva zero na posição para o loop de comentários, digamos segurança frente três

diga zero na posição para o comando agora valor do eixo um volte zero seguro na posição um decremente X

agora é zero, meu sinalizador ze está definido como zero, o que significa que meu branch Não, eu ia sair do loop, você acabou de

veja que saímos do loop sem esvaziar a aquisição de memória 0 0 então esse é o nosso bug aqui.

Então, acabamos de encontrar na linguagem central o que os programadores chamam de algo assim por causa de um erro que

temos algumas vezes se você estiver executando um loop se estiver executando um loop distante ou um Y ou bloop ou qualquer

loop às vezes seu índice já está bagunçado.

Então, se começarmos do zero e cometermos um erro e você fizer uma última coisa e realmente emitir para concluir

Seu grupo.

Então foi exatamente isso que aconteceu aqui.

Estávamos meio decrementais, então se olharmos agora para o nosso código, isso significa que estamos meio que definindo

os valores 0 e decremento no time após reset.

Certo, então estamos discriminando.

Vai de 2 1 0 0 acaba de sair, então como podemos consertar isso direito?

Temos que encontrar uma maneira de inverter essas coisas. Bem, de duas maneiras.

Certo.

Do jeito muito preguiçoso também, eu poderia simplesmente vir aqui e dizer Uau, eu sei que cometi um erro

então eu poderia simplesmente vir aqui e dizer bem, certifique-se de que depois que eu sair meu loop comece do zero certo, começamos

a que tem zero a gente começa a zerar na posição zero que vai ficar meio acordado bem tarde.

Mas também penso o contrário, que não é melhor nem pior, mas é apenas um caminho diferente.

Eu também poderia pensar assim, já que estou armazenando primeiro e depois o Dick fermentando, não deveria pense sobre

primeiro decremental e depois armazenado.

Certo.

Então, se eu vier aqui rapidamente e mudar essas duas linhas, eu poderia voltar aqui e dizer bem

agora somos decrescentes primeiro.

Portanto, permanecemos com meu zero armazenando na posição zero e depois testando.

Certo.

E Hussein foi derrubado.

OK, mas espere nosso banco e nosso ramo, se não for igual, teste o sinalizador Zero.

Então, o fato de você estar incrementando primeiro e depois fazendo uma estimativa não é uma bagunça

configure seu teste de bandeira Zero.

Não, não iria atrapalhar porque o dever da instrução não modifica nenhum sinalizador da instrução de decremento

define flex, mas o FDA não altera nenhum sinalizador, o que significa que haverá uma necessidade aqui.

Ainda estaremos testando o sinalizador Zero de nosso D anterior, ex nosso decremento anterior.

Então, se eu pudesse inverter essas coisas, só quero ressaltar que ainda está tudo bem, já que o FDA

não modifica o flexionado é testar o resultado do D X para que fique OK

não estar OK porque fazendo isso inversamente certo, comentando primeiro e depois definindo zero mais X, estaremos

meio que bagunçando nosso F F certo.

Estamos começando em F F os comentários estão prontos para f e e então começando em 0 20 então estamos basicamente apenas

meio que cometendo o mesmo erro.

Mas na ordem e então sim, eu ainda teria que talvez vir aqui e talvez eu possa simplesmente vir

entre e diga bem, armazene a que tem zero de direito.

Acabou de começar a zerar o armazenamento de restauração e certifique-se de que isso seja verdade, certifique-se de que F seja 0 8 antes

o loop começa.

Então, sim, tudo bem.

Então, novamente, nem melhor, nem pior.

Podemos pensar sobre isso, mas somos tratados teoricamente consertando da maneira certa.

Eu começo f f e certifico-me de definir um zero e um quinto e então decremental F E começo a zero voltar

f b aqui e então um set zero disse 0 2 1 Loop 0 set zero até a posição zero e então sai da minha

loop, novamente, apenas uma rápida revisão de por que este foi o primeiro sem erro na montagem e como

poderia basicamente rapidamente, basicamente e rapidamente, apenas hackear para fazer isso funcionar.
